# 我的 Go 后端开发学习笔记

本文档整理了从 Go 语法到构建一个完整分层 Web 应用的全过程，记录了其中的关键概念和我的个人理解。

## 目录

- [第一部分：Go 语言核心概念](#第一部分go-语言核心概念)
  - [1.1 Go 的设计哲学：简化的 C？](#11-go-的设计哲学简化的-c)
  - [1.2 Go 基础语法快速参考](#12-go-基础语法快速参考)
- [第二部分：构建 Web 服务器](#第二部分构建-web-服务器)
  - [2.1 标准库 `net/http` 的核心](#21-标准库-nethttp-的核心)
  - [2.2 升级到 Gin 框架](#22-升级到-gin-框架)
  - [2.3 我的 Gin 核心工作流总结](#23-我的-gin-核心工作流总结)
- [第三部分：专业项目架构](#第三部分专业项目架构)
  - [3.1 为什么需要分层架构？](#31-为什么需要分层架构)
  - [3.2 Go 的经典分层模型](#32-go-的经典分层模型)
- [第四部分：数据库集成](#第四部分数据库集成)
  - [4.1 Go 的数据库哲学 vs Django](#41-go-的数据库哲学-vs-django)
  - [4.2 数据库迁移 (`golang-migrate`)](#42-数据库迁移-golang-migrate)
  - [4.3 与数据库交互 (`database/sql`)](#43-与数据库交互-databasesql)
- [第五部分：架构思想的升华](#第五部分架构思想的升华)
  - [5.1 我的理解：依赖注入与驱动导入](#51-我的理解依赖注入与驱动导入)
  - [5.2 我的想法：`main.go` 的进一步解耦](#52-我的想法maingo-的进一步解耦)
- [第六部分：开发工作流](#第六部分开发工作流)
  - [6.1 热重载：让开发更流畅](#61-热重载让开发更流畅)

---

## 第一部分：Go 语言核心概念

### 1.1 Go 的设计哲学：简化的 C？

这个类比很贴切，但不完全准确。更准确的说法是：

> Go 是 C 语言在21世纪的**精神继承者**。它保留了 C 的高性能和简洁语法，但用现代化的方案彻底解决了 C 的历史遗留问题。

- **相似之处 (像 C)**: 编译型、静态类型、性能高、语法风格相似。
- **革命性改进 (超越 C)**:
  - **内置垃圾回收 (GC)**: 无需手动管理内存 (`malloc`/`free`)，像 Java/Python 一样安全。
  - **内置原生并发**: `goroutine` 和 `channel` 让并发编程变得前所未有的简单和安全。
  - **更安全的指针**: 保留了指针的概念 (`&` 和 `*`)，但**移除了指针运算**，杜绝了大量安全漏洞。
  - **强大的标准库和工具链**: 内置格式化、测试、构建工具，标准库足以构建高性能 Web 服务。

### 1.2 Go 基础语法快速参考

| 特性 | C 语言 | Go 语言 & 我的理解 |
| :--- | :--- | :--- |
| **变量声明** | `int a = 10;` | `var a int = 10` 或 `a := 10` (类型后置，`:=` 自动推断，更常用) |
| **函数定义** | `int add(int a, int b)` | `func add(a, b int) int` (类型后置，支持多返回值) |
| **`if-else`** | `if (x > 0) { ... }` | `if x > 0 { ... }` (无需括号，更简洁) |
| **循环** | `for`, `while`, `do-while` | 只有 `for` 关键字，但能实现所有循环形式。 |
| **结构体** | `struct Point { ... };` | `type Point struct { ... }` (更简洁，首字母大写表示公共) |
| **指针** | `int* p = &a; p++;` | `p := &a` (概念相同，但**不支持指针运算**，更安全) |
| **数组/切片**| `int arr[5];` (固定) | `[]int{1,2}` (切片 Slice 是动态的，更常用，类似 Python 的 list) |

---

## 第二部分：构建 Web 服务器

### 2.1 标准库 `net/http` 的核心

- **`http.ResponseWriter`**: 代表**服务器的响应**。它是一个接口，可以把它想象成一张空白的信纸，我们用它来写入响应内容、状态码和头信息。
- **`http.Request`**: 代表**客户端的请求**。它是一个结构体，包含了请求的 URL、方法、头信息、请求体等所有信息。
- **`http.Handler`**: 一个**处理器接口**。任何实现了 `ServeHTTP(w, r)` 方法的类型都是一个 Handler。它是 Go Web 中所有可处理请求单元的通用抽象。
- **中间件**: 一个接收 `http.Handler` 并返回一个新的 `http.Handler` 的函数。它像洋葱皮一样将核心处理器包裹起来，用于添加日志、鉴权等通用功能。

### 2.2 升级到 Gin 框架

- **为什么需要？** 标准库不支持 RESTful API 中常见的**路径参数** (如 `/users/:id`)。
- **Gin 是什么？** 一个高性能的**微型框架**，提供了路由、中间件、JSON 渲染、验证器等丰富功能，对新手非常友好。

### 2.3 我的 Gin 核心工作流总结

> 简单来说，就是先**写处理器方法**，然后这个方法期望接受一个 `c *gin.Context`，因为无论如何，**任何信息都在这个 context 中**。
> 
> 然后我们再通过 `r.GET(...)` 这种语法进行**路径与处理器的绑定**。
> 
> 在处理器方法中，要正确地进行状态码返回，就可以使用 `http.StatusOK` 这种快捷方式来进行**快捷响应**。

---

## 第三部分：专业项目架构

### 3.1 为什么需要分层架构？

和 Spring Boot、Django 一样，为了实现**关注点分离**，让代码更清晰、可维护、可测试。

### 3.2 Go 的经典分层模型

- **Handler (HTTP 层)**: 唯一关心 HTTP 的层。负责解析请求、调用 Service、返回响应。
- **Service (业务逻辑层)**: 应用的“大脑”。实现核心业务规则，完全不关心 HTTP 和数据库。
- **Repository (数据访问层)**: 唯一的“数据专家”。负责与数据库进行增删改查交互。
- **Model (领域模型层)**: 最纯粹的数据结构定义，通常与数据库表结构对应。

---

## 第四部分：数据库集成

### 4.1 Go 的数据库哲学 vs Django

- **迁移**: Go **没有内置迁移**。需要使用 `golang-migrate/migrate` 这样的第三方工具，手动编写 SQL 文件。
- **ORM**: Go **没有内置 ORM**。标准库 `database/sql` 需要手动编写 SQL，提供了最大的灵活性。也可以选择 GORM 等第三方 ORM 库。

### 4.2 数据库迁移 (`golang-migrate`)

1.  **安装工具**: `go install -tags 'mysql' ...`
2.  **创建迁移文件**: `migrate create -ext sql -dir db/migrations ...`
3.  **编写 SQL**: 手动填充 `.up.sql` (迁移) 和 `.down.sql` (回滚) 文件。
4.  **执行迁移**: `migrate -database '...' -path ... up`

### 4.3 与数据库交互 (`database/sql`)

- **`sql.Open()`**: 获取一个数据库句柄（连接池），但不会立即建立连接。
- **`db.Ping()`**: 验证数据库连接是否有效。
- **`db.Exec()`**: 用于执行不返回数据的操作（`INSERT`, `UPDATE`, `DELETE`）。
- **`db.QueryRow().Scan()`**: 用于查询单行数据，并将结果映射到 `struct` 的字段中。

---

## 第五部分：架构思想的升华

### 5.1 我的理解：依赖注入与驱动导入

> 不管是 `repository` 还是其他的什么层，都**不关心基础配置**，例如数据库驱动这种。
> 
> 这些是必须要在项目**启动最开始时进行配置的**，所以自然而然地，就在主文件 `main.go` 中的 `main` 函数里进行配置。
> 
> 那既然都是在这里配置了，肯定也**要在这里进行引入**（比如 `import _ "..."`）。
> 
> 然后，等我们完成了配置之后，就在这里调用 `repository` 的构造函数，**传入我们已经建立好链接的对象**，来保证之后工作的顺利。

### 5.2 我的想法：`main.go` 的进一步解耦

> `main.go` 中完成的操作也很多，**是否应该进一步解耦**？
> 
> 我的想法是，对链接建立和数据库连接传入的操作，**封装到对应的 `db` 工具文件内**。这样做的目的，就是为了**进一步解耦，也让 `main.go` 显得更加简洁，可读性更强**。

---

## 第六部分：开发工作流

### 6.1 热重载：让开发更流畅

- **问题**: Go 是编译型语言，`go run` 不会自动重载。
- **解决方案**: 使用第三方工具 `Air`。
- **使用方法**:
  1.  **安装**: `go install github.com/cosmtrek/air@latest` (只需一次)。
  2.  **启动**: 在项目根目录，用 `air` 命令代替 `go run main.go` 来启动服务。

`Air` 会自动监视文件变化，并重新编译、运行你的应用，极大提升开发效率。
