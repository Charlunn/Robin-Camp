name: CI

on:
  push:
    branches:
      - main
      - dev
  pull_request:
    branches:
      - main
      - dev

jobs:
  build:
    runs-on: self-hosted
    env:
      IMAGE_TAG: ${{ github.sha }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Load registry configuration
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_NAME_RAW="${{ vars.IMAGE_NAME || 'cinema' }}"
          IMAGE_NAME="$(printf '%s' "$IMAGE_NAME_RAW" | tr '[:upper:]' '[:lower:]')"
          echo "IMAGE_NAME=$IMAGE_NAME" >> "$GITHUB_ENV"
          REGISTRY_USERNAME_RAW="${{ vars.REGISTRY_USERNAME || github.repository_owner }}"
          REGISTRY_USERNAME="$(printf '%s' "$REGISTRY_USERNAME_RAW" | tr '[:upper:]' '[:lower:]')"
          echo "REGISTRY_USERNAME=$REGISTRY_USERNAME" >> "$GITHUB_ENV"

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'
          cache: true

      - name: Go vet
        run: go vet ./...
        working-directory: cinema

      - name: Run unit tests
        run: go test ./...
        working-directory: cinema

      - name: Build Docker image
        run: docker build -t "$IMAGE_NAME:$IMAGE_TAG" -f cinema/Dockerfile cinema

      - name: Save Docker image artifact
        shell: bash
        run: |
          docker save "$IMAGE_NAME:$IMAGE_TAG" | gzip > image.tar.gz

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: cinema-image
          path: image.tar.gz
          retention-days: 1

  deploy:
    runs-on: self-hosted
    needs: build
    env:
      IMAGE_TAG: ${{ github.sha }}
      DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
    concurrency:
      group: deploy-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Load registry configuration
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_NAME_RAW="${{ vars.IMAGE_NAME || 'cinema' }}"
          IMAGE_NAME="$(printf '%s' "$IMAGE_NAME_RAW" | tr '[:upper:]' '[:lower:]')"
          echo "IMAGE_NAME=$IMAGE_NAME" >> "$GITHUB_ENV"
          REGISTRY_USERNAME_RAW="${{ vars.REGISTRY_USERNAME || github.repository_owner }}"
          REGISTRY_USERNAME="$(printf '%s' "$REGISTRY_USERNAME_RAW" | tr '[:upper:]' '[:lower:]')"
          echo "REGISTRY_USERNAME=$REGISTRY_USERNAME" >> "$GITHUB_ENV"

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: cinema-image
          path: artifacts

      - name: Load Docker image
        shell: bash
        run: |
          gunzip -c artifacts/image.tar.gz | docker load

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.REGISTRY_USERNAME }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push image to GitHub Container Registry
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_REF="ghcr.io/${REGISTRY_USERNAME}/$IMAGE_NAME:${IMAGE_TAG}"
          docker tag "$IMAGE_NAME:${IMAGE_TAG}" "$IMAGE_REF"
          docker push "$IMAGE_REF"
          echo "IMAGE_REF=$IMAGE_REF" >> "$GITHUB_ENV"

      - name: Prepare deployment workspace
        shell: bash
        run: |
          set -euo pipefail
          DEPLOY_DIR="${DEPLOY_PATH:-$GITHUB_WORKSPACE/deploy}"
          mkdir -p "$DEPLOY_DIR"
          rsync -a --delete --exclude '.git' --exclude '.github' --exclude '.env' "$GITHUB_WORKSPACE/cinema/" "$DEPLOY_DIR/"
          echo "DEPLOY_DIR=$DEPLOY_DIR" >> "$GITHUB_ENV"

      - name: Generate deployment environment file
        shell: bash
        env:
          APP_IMAGE_SECRET: ${{ secrets.APP_IMAGE }}
          AUTH_TOKEN_SECRET: ${{ secrets.AUTH_TOKEN }}
          BOXOFFICE_API_KEY_SECRET: ${{ secrets.BOXOFFICE_API_KEY }}
          BOXOFFICE_URL_SECRET: ${{ secrets.BOXOFFICE_URL }}
          DB_URL_SECRET: ${{ secrets.DB_URL }}
          FRONTEND_API_BASE_URL_SECRET: ${{ secrets.FRONTEND_API_BASE_URL }}
          IMAGE_NAME_SECRET: ${{ secrets.IMAGE_NAME }}
          PORT_SECRET: ${{ secrets.PORT }}
          POSTGRES_PORT_SECRET: ${{ secrets.POSTGRES_PORT }}
          POSTGRES_DB_SECRET: ${{ secrets.POSTGRES_DB }}
          POSTGRES_PASSWORD_SECRET: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_USER_SECRET: ${{ secrets.POSTGRES_USER }}
          REGISTRY_USERNAME_SECRET: ${{ secrets.REGISTRY_USERNAME }}
        run: |
          set -euo pipefail
          DEPLOY_DIR="${DEPLOY_DIR:-${DEPLOY_PATH:-$GITHUB_WORKSPACE/deploy}}"
          ENV_FILE="$DEPLOY_DIR/.env"

          REQUIRED_VARS=(
            AUTH_TOKEN_SECRET
            BOXOFFICE_API_KEY_SECRET
            BOXOFFICE_URL_SECRET
            DB_URL_SECRET
            FRONTEND_API_BASE_URL_SECRET
            PORT_SECRET
            POSTGRES_DB_SECRET
            POSTGRES_PASSWORD_SECRET
            POSTGRES_USER_SECRET
          )

          MISSING=()
          for VAR_NAME in "${REQUIRED_VARS[@]}"; do
            if [ -z "${!VAR_NAME:-}" ]; then
              MISSING+=("${VAR_NAME%_SECRET}")
            fi
          done

          if [ "${#MISSING[@]}" -ne 0 ]; then
            printf 'The following required secrets are missing: %s\n' "${MISSING[*]}" >&2
            exit 1
          fi

          {
            printf 'APP_IMAGE=%s\n' "${APP_IMAGE_SECRET}"
            printf 'AUTH_TOKEN=%s\n' "${AUTH_TOKEN_SECRET}"
            printf 'BOXOFFICE_API_KEY=%s\n' "${BOXOFFICE_API_KEY_SECRET}"
            printf 'BOXOFFICE_URL=%s\n' "${BOXOFFICE_URL_SECRET}"
            printf 'DB_URL=%s\n' "${DB_URL_SECRET}"
            printf 'FRONTEND_API_BASE_URL=%s\n' "${FRONTEND_API_BASE_URL_SECRET}"
            printf 'IMAGE_NAME=%s\n' "${IMAGE_NAME_SECRET}"
            printf 'PORT=%s\n' "${PORT_SECRET}"
            printf 'POSTGRES_DB=%s\n' "${POSTGRES_DB_SECRET}"
            printf 'POSTGRES_PASSWORD=%s\n' "${POSTGRES_PASSWORD_SECRET}"
            printf 'POSTGRES_PORT=%s\n' "${POSTGRES_PORT_SECRET:-5432}"
            printf 'POSTGRES_USER=%s\n' "${POSTGRES_USER_SECRET}"
            printf 'REGISTRY_USERNAME=%s\n' "${REGISTRY_USERNAME_SECRET}"
          } >"$ENV_FILE"

          chmod 600 "$ENV_FILE"

      - name: Ensure environment file exists
        shell: bash
        run: |
          set -euo pipefail
          DEPLOY_DIR="${DEPLOY_DIR:-${DEPLOY_PATH:-$GITHUB_WORKSPACE/deploy}}"
          if [ ! -f "$DEPLOY_DIR/.env" ]; then
            echo "A .env file with deployment secrets must exist in $DEPLOY_DIR" >&2
            exit 1
          fi

      - name: Update deployment image reference
        shell: bash
        run: |
          set -euo pipefail
          DEPLOY_DIR="${DEPLOY_DIR:-${DEPLOY_PATH:-$GITHUB_WORKSPACE/deploy}}"
          if grep -q '^APP_IMAGE=' "$DEPLOY_DIR/.env"; then
            sed -i "s|^APP_IMAGE=.*|APP_IMAGE=${IMAGE_REF}|" "$DEPLOY_DIR/.env"
          else
            echo "APP_IMAGE=${IMAGE_REF}" >> "$DEPLOY_DIR/.env"
          fi

      - name: Deploy application
        shell: bash
        run: |
          set -euo pipefail
          DEPLOY_DIR="${DEPLOY_DIR:-${DEPLOY_PATH:-$GITHUB_WORKSPACE/deploy}}"
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "$REGISTRY_USERNAME" --password-stdin
          docker pull "$IMAGE_REF"
          cd "$DEPLOY_DIR"
          docker compose pull
          docker compose up -d --remove-orphans
          docker image prune -f

      - name: Install E2E test dependencies
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            if command -v sudo >/dev/null 2>&1; then
              sudo apt-get update
              sudo apt-get install -y jq
            else
              apt-get update
              apt-get install -y jq
            fi
          fi

      - name: Run E2E tests
        shell: bash
        run: |
          set -euo pipefail
          DEPLOY_DIR="${DEPLOY_DIR:-${DEPLOY_PATH:-$GITHUB_WORKSPACE/deploy}}"
          cd "$DEPLOY_DIR"
          chmod +x ./e2e-test.sh
          ./e2e-test.sh

